#!/usr/bin/perl -w
use strict;
use warnings;

use FindBin qw($Script $Bin);

# If the program runs as /foobar/bin/program, find libraries in /foobar/lib
my ($base, %state, %pids, $private_socket);
BEGIN {
    # Even on windows FindBin uses / in the reported path
    $Bin = $FindBin::Bin;
    $Bin =~ s{/+\z}{};
    $Bin =~
        ($^O eq "MSWin32" ?
         qr{^((?:[A-Z]:)?(?:/[a-zA-Z0-9_:.~ -]+)*)/[a-zA-Z0-9_.-]+/*\z} :
         qr{^((?:/[a-zA-Z0-9_:.-]+)*)/[a-zA-Z0-9_.-]+/*\z}) ||
         die "Could not parse bin directory '$Bin'";
    # Use untainted version of lib
    my $base = $1;
    require lib;
    # Support a simple --blib option for pre-install testing
    "lib"->import(@ARGV && $ARGV[0] eq "--blib" ? shift && "$base/blib/lib" : "$base/lib");
}

use Errno qw(ENOENT ESTALE);
use IO::Socket::UNIX;

use constant {
    PATH_BASE	=> "state/Git-ExportDaemon",
};

use constant {
    PATH_STATE	=> PATH_BASE . "/state",
    PATH_EXPORT	=> PATH_BASE . "/export",
    PATH_STAGE	=> PATH_BASE . "/stage",
    PATH_SOCKET	=> PATH_BASE . "/S.git-exportd",
    LOCK_PATH	=> PATH_BASE . "/git-exportd.lock",
};

use Git::ExportDaemon qw
    (CODE_QUIT CODE_WRONG_ARGUMENTS CODE_UNKNOWN_REVISION CODE_GIT_ERROR
     CODE_EXPORTED CODE_UNKNOWN_COMMAND CODE_INVALID_REPO CODE_HELP
     is_systemd report mkdirs rmtree git_rev_parse git_dir run_piped
     escape unescape lock_file cwd_path);

my $umask = 022;

{
    my $stage_id = "A";
    sub stage_tmp {
        my $id = $stage_id++;
        # Gives just the fresh path in scalar context
        return $id, PATH_STAGE . "/$id";
    }
}

sub stage_delete {
    for my $path (@_) {
        report("info", "removing $path");
        my $stage = stage_tmp();
        rename($path, $stage) || die "Could not rename '$path' to '$stage': $!";
    }
}

sub stage_clean {
    rmtree(PATH_STAGE, keep_top => 1, silent => 1);
}

sub state_read {
    %state = ();
    %pids = ();

    my $dir = PATH_STATE;
    opendir(my $dh, $dir) || die "Could not opendir '$dir': $!";
    for my $f (readdir($dh)) {
        next if $f eq "." || $f eq "..";
        my $path = "$dir/$f";
        if (my ($revision) = $f =~ /^([0-9a-f]{40})\z/) {
            my $exp_path = PATH_EXPORT . "/$f";
            lstat($exp_path) || $! == ENOENT || $! == ESTALE ||
                die "Could not lstat($exp_path): $!";
            if (-d _) {
                open(my $fh, "<", $path) || die "Could not open '$path': $!";
                local $_;
                while (<$fh>) {
                    my ($pid) = /^(\d+)\n/ or do {
                        report("warning", "State file '$path' is damaged");
                        last;
                    };
                    $state{$revision}{$pid} ||= 1;
                    $pids{$pid}{$revision} ||= 1;
                }
                next;
            }
        }
        rmtree($path);
    }
    closedir($dh) || die "Could not closedir '$dir': $!";

    # Check if any pids are gone
    my %update;
    while (my ($pid, $revisions) = each %pids) {
        next if kill(0, $pid) && $pid != $$ && $pid > 1;
        delete $pids{$pid};
        my @revisions = keys %$revisions;
        @update{@revisions} = ();
        for my $revision (@revisions) {
            delete $state{$revision}{$pid};
        }
    }

    # Rewrite the state file for any pids that are gone
    for my $revision (keys %update) {
        my $path = "$dir/$revision";
        my @pids = sort { $a <=> $b } keys %{$state{$revision}};
        if (@pids) {
            my $tmp = stage_tmp();
            open(my $fh, ">>", $tmp) ||
                die "Could not append to '$tmp': $!";
            eval {
                print($fh map "$_\n", @pids) ||
                    die "Could not write to '$tmp': $!";
                close($fh) || die "Could not close '$tmp': $!";
                rename($tmp, $path) ||
                    die "Could not rename '$tmp' to '$path': $!";
            };
            if (my $err = $@) {
                stage_clean();
                die $err;
            }
        } else {
            delete $state{$revision};
            rmtree($path);
        }
    }

    # Clean up any exports we don't know about
    my $exp_dir = PATH_EXPORT;
    opendir($dh, $exp_dir) || die "Could not opendir '$exp_dir': $!";
    my $delete;
    for my $f (readdir($dh)) {
        next if $f eq "." || $f eq "..";
        my $path = "$exp_dir/$f";
        next if exists $state{$f};
        $delete ||= 1;
        stage_delete($path);
    }
    stage_clean() if $delete;

    closedir($dh) || die "Could not closedir '$exp_dir': $!";
}

sub register {
    my ($revision, $pid) = @_;

    return if exists $state{$revision} && $state{$revision}{$pid};

    my $file = PATH_STATE . "/$revision";
    open(my $fh, ">>", $file) || die "Could not open '$file' for append: $!";
    print($fh "$pid\n") || die "Could not write to '$file': $!";
    close($fh) || die "Error closing '$file': $!";
    $state{$revision}{$pid} ||= 1;
    $pids{$pid}{$revision}  ||=1;
}

sub on_quit {
    my ($client, $reason) = @_;

    my $id = $client->id;
    report("info", "Client '$id' quit: $reason");

    # Maybe we shut down because the given pid is gone...
    my $pid = $client->pid;
    if (!kill(0, $pid)) {
        if (my $revisions = delete $pids{$pid}) {
            for my $revision (keys %$revisions) {
                delete $state{$revision}{$pid};
                delete $state{$revision} if !%{$state{$revision}};
            }
            # Be more carefull deleting in PATH_EXPORT
            # We want absolutely no risk of partial deletes
            my $delete;
            my $exp_dir = PATH_EXPORT;
            for my $revision (keys %$revisions) {
                next if $state{$revision};
                rmtree(PATH_STATE . "/$revision");
                my $path = "$exp_dir/$revision";
                lstat($path) || $! == ENOENT || $! == ESTALE ||
                    die "Could not lstat($path): $!";
                if (-e _) {
                    $delete ||= 1;
                    stage_delete($path);
                }
            }
            stage_clean() if $delete;
        }
    }
}

sub export {
    my ($client, $repo, $commit) = @_;

    my $dir = PATH_EXPORT;
    if (!-d $repo) {
        if (-e _) {
            $client->output(CODE_INVALID_REPO, "Repository is not a directory");
        } else {
            $client->output(CODE_INVALID_REPO, "Repository does not exist");
        }
        return;
    }
    if (!defined git_dir($repo)) {
        $client->output(CODE_INVALID_REPO, "Directory '$repo' is not a repository");
        return;
    }
    my $revision = git_rev_parse($repo, $commit) // do {
        $client->output(CODE_UNKNOWN_REVISION, "Unknown revision $commit");
        return;
    };
    register($revision, $client->pid);
    my $path = "$dir/$revision";
    if (-d $path) {
        report("info", "Already have $commit exported as $path");
    } else {
        report("info", "Git exporting $commit as $path");
        my ($id, $stage_path) = stage_tmp();
        my $out = run_piped(
            [["git", "archive", "--prefix=$id/", $revision], $repo],
            [["tar", "-x"], PATH_STAGE]);
        if (!defined $out) {
            stage_clean();
            $client->output(CODE_GIT_ERROR, "Git error");
            return;
        }
        rename($stage_path, $path) || do {
            my $err = $@;
            stage_clean();
            die $err;
        };
    }
    $path = cwd_path(escape($path));
    $client->output(CODE_EXPORTED, $path);
}

sub on_line {
    my ($client, $line) = @_;

    my @args = split " ", $line or return;
    $_ = unescape($_) for @args;
    my $command = uc shift @args;
    my $id    = $client->id;

    if ($command eq "EXPORT") {
        if (@args < 1) {
            $client->output(CODE_WRONG_ARGUMENTS, "Missing argument(s)");
            return;
        }
        my $repo   = shift @args;
        my $commit = shift @args // "HEAD";
        if (@args) {
            $client->output(CODE_WRONG_ARGUMENTS, "Spurious argument(s)");
            return;
        }
        export($client, $repo, $commit);
        return;
    } elsif ($command eq "HELP") {
        $client->output(CODE_HELP, <<"EOT")
Commands supported:
EXPORT <repo> [<commit>]
QUIT
SHUTDOWN
HELP
EOT
            ;
    } elsif ($command eq "QUIT") {
        $client->finish(CODE_QUIT, "Manual quit", "Goodbye");
    } elsif ($command eq "SHUTDOWN") {
        Git::ExportDaemon->shutdown("Manual shutdown by client '$id'");
        # Cleanup before shutdown
        state_read();
    } else {
        $client->output(CODE_UNKNOWN_COMMAND, "Unknown command '$command'");
    }
}

sub on_accept {
    my ($client) = @_;

    my $pid   = $client->pid;
    my $user  = $client->user;
    my $group = $client->group;
    my $id    = $client->id;
    report("info", "Client '$id' connected: pid $pid, user $user, group $group");
}

my $lock;
eval {
    umask($umask);

    report("info", "Running as pid $$");

    mkdirs(PATH_BASE);
    $lock = lock_file(cwd_path(LOCK_PATH));

    my $fh = is_systemd();
    if ($fh) {
        stat($fh) or die "Could not stat passed filehandle: $!";
        -S $fh || die "Passed filehandle is not a socket\n";
    } else {
        my $fd = fileno(STDIN);
        if (defined $fd) {
            stat(STDIN) or die "Could not stat STDIN: $!";
            $fh = \*STDIN if -S _;
        }
        if (!$fh) {
            if (-e PATH_SOCKET) {
                -S _ || die "Path '", PATH_SOCKET, "' exists but is not a socket\n";
                die "Something is still listening on '", PATH_SOCKET, "'\n" if
                    IO::Socket::UNIX->new(Peer => PATH_SOCKET);
            } else {
                # Check for dangling symlink
                -l PATH_SOCKET;
            }
            !-e _ || unlink(PATH_SOCKET) || $! == ENOENT || $! == ESTALE ||
                    die "Could not unlink '", PATH_SOCKET, "': $!";
            $fh = IO::Socket::UNIX->new(
                Local => PATH_SOCKET,
                Listen => undef) ||
                    die "Could not open UNIX socket ", PATH_SOCKET, "($!)";
            $private_socket = PATH_SOCKET;
            report("info",
                   "Created listening socket '%s'", cwd_path($private_socket));
            -S $fh || die "Assertion: Just created IO::Socket::UNIX filehandle is not a socket";
        }
    }

    rmtree(PATH_STAGE, silent => 1);
    mkdir(PATH_STAGE, 0700) || die "Could not mkdir(", PATH_STAGE, "): $!";
    mkdirs(PATH_STATE);
    mkdirs(PATH_EXPORT);
    state_read();

    Git::ExportDaemon->init();
    Git::ExportDaemon->listener(
        $fh,
        on_quit   => \&on_quit,
        on_line   => \&on_line,
        on_accept => \&on_accept,
    );
    Git::ExportDaemon->loop();
    report("info", "Exit");
};
my $err = $@;
unlink($private_socket) if defined $private_socket;
if ($err) {
    report("err", $err);
    report("info", "Exit");
    die $err;
}
