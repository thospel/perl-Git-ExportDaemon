#!/usr/bin/perl -w
use strict;
use warnings;

use FindBin qw($Script $Bin);

# If the program runs as /foobar/bin/program, find libraries in /foobar/lib
my ($base, %uid_revision_pid, %uid_pid_revision, $private_socket);
BEGIN {
    # Even on windows FindBin uses / in the reported path
    $Bin = $FindBin::Bin;
    $Bin =~ s{/+\z}{};
    $Bin =~
        ($^O eq "MSWin32" ?
         qr{^((?:[A-Z]:)?(?:/[a-zA-Z0-9_:.~ -]+)*)/[a-zA-Z0-9_.-]+/*\z} :
         qr{^((?:/[a-zA-Z0-9_:.-]+)*)/[a-zA-Z0-9_.-]+/*\z}) ||
         die "Could not parse bin directory '$Bin'";
    # Use untainted version of lib
    my $base = $1;
    require lib;
    # Support a simple --blib option for pre-install testing
    "lib"->import(@ARGV && $ARGV[0] eq "--blib" ? shift && "$base/blib/lib" : "$base/lib");
}

use Errno qw(ENOENT ESTALE);
use IO::Socket::UNIX;

use constant {
    PATH_BASE	=> "state/Git-ExportDaemon",
};

use Git::ExportDaemon qw
    (CODE_QUIT CODE_WRONG_ARGUMENTS CODE_UNKNOWN_REVISION CODE_GIT_ERROR
     CODE_EXPORTED CODE_UNKNOWN_COMMAND CODE_INVALID_REPO CODE_HELP
     MODE NAME_SOCKET
     is_systemd report report_start mkdirs rmtree permtree git_rev_parse git_dir
     run_piped escape unescape lock_file cwd_path dir_rw dir_ro trust_check);

use constant {
    NAME_STATE	=> "state",
    NAME_EXPORT	=> "export",
    PATH_STAGE	=> PATH_BASE . "/stage",
    PATH_SOCKET	=> PATH_BASE . "/" . NAME_SOCKET,
    LOCK_PATH	=> PATH_BASE . "/git-exportd.lock",
};

my $umask = 022;

{
    my $to_delete = 0;
    my $stage_id = "A";
    sub stage_tmp {
        my $id = $stage_id++;
        # Gives just the fresh path in scalar context
        return $id, PATH_STAGE . "/$id";
        # Supposedly something will be placed in stage. Mark it for cleanup
        # Call unstage_tmp if you remove it from stage again
        ++$to_delete;
    }

    sub unstage_tmp {
        --$to_delete;
    }

    sub stage_delete {
        for my $path (@_) {
            report("info", "removing $path");
            my $stage = stage_tmp();
            # Make writable if directory so we can move it
            dir_rw($path);
            rename($path, $stage) || die "Could not rename '$path' to '$stage': $!";
        }
    }

    sub stage_clean {
        $to_delete || return;
        rmtree(PATH_STAGE, top_keep => 1, silent => 1);
        $to_delete = 0;
    }
}

# Caller is responsible for first doing dir_rw($dir)
sub state_read_uid {
    my ($dir, $revision_pid, $pid_revision) = @_;

    my $dir_state  = "$dir/" . NAME_STATE;
    my $dir_export = "$dir/" . NAME_EXPORT;

    # If these fail the caller will kill the whole uid
    eval { dir_rw($dir_state ) } || return;
    eval { dir_rw($dir_export, 0700) } || return;

    opendir(my $dh, $dir_state) || die "Could not opendir '$dir_state': $!";
    for my $f (readdir($dh)) {
        next if $f eq "." || $f eq "..";
        my $path_state = "$dir_state/$f";
        if (my ($revision) = $f =~ /^([0-9a-f]{40})\z/) {
            my $path_export = "$dir_export/$f";
            lstat($path_export) || $! == ENOENT || $! == ESTALE ||
                die "Could not lstat($path_export): $!";
            if (-d _) {
                open(my $fh, "<", $path_state) || die "Could not open '$path_state': $!";
                local $_;
                while (<$fh>) {
                    my ($pid) = /^(\d+)\n/ or do {
                        report("warning", "State file '$path_state' is damaged");
                        last;
                    };
                    $revision_pid->{$revision}{$pid} ||= 1;
                    $pid_revision->{$pid}{$revision} ||= 1;
                }
                next;
            }
        }
        rmtree($path_state);
    }
    closedir($dh) || die "Could not closedir '$dir_state': $!";

    # Check if any pids are gone
    my %update;
    while (my ($pid, $revisions) = each %$pid_revision) {
        next if kill(0, $pid) && $pid != $$ && $pid > 1;
        delete $pid_revision->{$pid};
        my @revisions = keys %$revisions;
        @update{@revisions} = ();
        for my $revision (@revisions) {
            delete $revision_pid->{$revision}{$pid};
        }
    }

    if (!%$pid_revision) {
        report("info", "Fast delete of $dir");
        %$revision_pid = ();
        # stage_delete currently unneeded
        # (caller will kill containing directory)
        # stage_delete($dir_state);
        # stage_delete($dir_export);
        return;
    }

    # Rewrite the state file for any pids that are gone
    for my $revision (keys %update) {
        my $path_state = "$dir_state/$revision";
        my @pids = sort { $a <=> $b } keys %{$revision_pid->{$revision}};
        if (@pids) {
            my $tmp = stage_tmp();
            open(my $fh, ">>", $tmp) ||
                die "Could not append to '$tmp': $!";
            print($fh map "$_\n", @pids) ||
                die "Could not write to '$tmp': $!";
            close($fh) || die "Could not close '$tmp': $!";
            rename($tmp, $path_state) ||
                die "Could not rename '$tmp' to '$path_state': $!";
            unstage_tmp();
        } else {
            delete $revision_pid->{$revision};
            rmtree($path_state);
        }
    }

    # Clean up any exports we don't know about
    opendir($dh, $dir_export) || die "Could not opendir '$dir_export': $!";
    for my $f (readdir($dh)) {
        next if $f eq "." || $f eq "..";
        my $path_export = "$dir_export/$f";
        next if exists $revision_pid->{$f};
        stage_delete($path_export);
    }

    closedir($dh) || die "Could not closedir '$dir_export': $!";
}

sub state_read {
    my $uid_revision_pid = {};
    my $uid_pid_revision = {};

    my $dir = PATH_BASE;
    eval {
        opendir(my $dh, $dir) || die "Could not opendir '$dir': $!";
        for my $f (readdir($dh)) {
            if ($f eq NAME_EXPORT || $f eq NAME_STATE) {
                # Cleanup directories at the wrong level
                stage_delete("$dir/$f");
                next;
            }
            my ($uid) = $f =~ /^([1-9][0-9]*|0)\z/ or next;
            my $path = "$dir/$uid";

            if (!dir_rw($path)) {
                # Not a directory!
                report("warning", "User area $path is not in fact a directory");
                unlink($path) || $! == ENOENT || $! == ESTALE ||
                    die "Could not unlink($path): $!";
                next;
            }

            state_read_uid($path,
                           $uid_revision_pid->{$uid} ||= {},
                           $uid_pid_revision->{$uid} ||= {});
            if (%{$uid_revision_pid->{$uid}}) {
                %{$uid_pid_revision->{$uid}} ||
                    die "Assertion: Inconsistent pid/revision state";
            } else {
                # Possibly keep this dir for caching
                # But if so you may need to fixup export and state since
                # state_read_uid currently doesn't bother if it knows uid will
                # get cleaned up
                stage_delete($path);
                %{$uid_pid_revision->{$uid}} &&
                    die "Assertion: Inconsistent pid/revision state";
                delete $uid_revision_pid->{$uid};
                delete $uid_pid_revision->{$uid};
            }
        }
        %uid_revision_pid = %$uid_revision_pid;
        %uid_pid_revision = %$uid_pid_revision;
    };
    my $err = $@;
    stage_clean();
    die $err if $err;
}

sub register {
    my ($uid, $pid, $revision) = @_;

    # Avoid autovivify to keep the datastructure consistent even if the file
    # write fails
    return if
        exists $uid_revision_pid{$uid} &&
        exists $uid_revision_pid{$uid}{$revision} &&
        $uid_revision_pid{$uid}{$revision}{$pid};

    my $dir_uid = PATH_BASE . "/$uid";
    # Don't check return, the open will implicitely report any problems
    mkdir($dir_uid);
    my $dir_state = "$dir_uid/" . NAME_STATE;
    # Don't check return, the open will implicitely report any problems
    mkdir($dir_state);

    my $file = "$dir_state/$revision";
    open(my $fh, ">>", $file) || die "Could not open '$file' for append: $!";
    print($fh "$pid\n") || die "Could not write to '$file': $!";
    close($fh) || die "Error closing '$file': $!";
    $uid_revision_pid{$uid}{$revision}{$pid} ||= 1;
    $uid_pid_revision{$uid}{$pid}{$revision} ||=1;
}

sub on_quit {
    my ($client, $reason) = @_;

    my $id = $client->id;
    report("info", "Client '$id' quit: $reason");

    # Maybe we shut down because the given pid is gone...
    my $pid = $client->pid;
    my $uid = $client->uid;
    my $dir_uid = PATH_BASE . "/$uid";
    my $pid_revision = $uid_pid_revision{$uid};
    my $revision_pid = $uid_revision_pid{$uid};
    if ($pid_revision && !kill(0, $pid)) {
        if (my $revisions = delete $pid_revision->{$pid}) {
            if (%$pid_revision) {
                # Still something left
                for my $revision (keys %$revisions) {
                    delete $revision_pid->{$revision}{$pid};
                    delete $revision_pid->{$revision} if !%{$revision_pid->{$revision}};
                }
                my $dir_state  = "$dir_uid/" . NAME_STATE;
                my $dir_export = "$dir_uid/" . NAME_EXPORT;
                for my $revision (keys %$revisions) {
                    next if $revision_pid->{$revision};
                    rmtree("$dir_state/$revision");
                    # Be more carefull deleting in $dir_export
                    # We want absolutely no risk of partial deletes
                    my $path_export = "$dir_export/$revision";
                    lstat($path_export) || $! == ENOENT || $! == ESTALE ||
                        die "Could not lstat($path_export): $!";
                    stage_delete($path_export) if -e _;
                }
            } else {
                delete $uid_pid_revision{$uid};
                delete $uid_revision_pid{$uid};
                stage_delete($dir_uid);
            }
            stage_clean();
        }
    }
}

sub export {
    my ($client, $repo, $commit) = @_;

    my $uid = $client->uid;
    my $dir_export = PATH_BASE . "/$uid/" . NAME_EXPORT;
    if (!-d $repo) {
        if (-e _) {
            $client->output(CODE_INVALID_REPO, "Repository is not a directory");
        } else {
            $client->output(CODE_INVALID_REPO, "Repository does not exist");
        }
        return;
    }
    if (!defined git_dir($repo)) {
        $client->output(CODE_INVALID_REPO, "Directory '$repo' is not a repository");
        return;
    }
    my $revision = git_rev_parse($repo, $commit) // do {
        $client->output(CODE_UNKNOWN_REVISION, "Unknown revision $commit");
        return;
    };
    register($uid, $client->pid, $revision);
    my $path_export = "$dir_export/$revision";
    if (-d $path_export) {
        report("info", "Already have $commit exported as $path_export");
    } else {
        report("info", "Git exporting $commit as $path_export");
        # Don't check return of mkdir. The rename will implicitely check it
        mkdir($dir_export, 0700);
        my ($id, $stage_path) = stage_tmp();
        my $out = run_piped(
            [["git", "archive", "--prefix=$id/", $revision], $repo],
            [["tar", "--no-same-permissions", "-x"], PATH_STAGE]);
        if (!defined $out) {
            stage_clean();
            $client->output(CODE_GIT_ERROR, "Git error");
            return;
        }
        # Allow r-x, but preserve the top level directory or we cannot rename
        permtree($stage_path, 0555, top_keep => 1);
        rename($stage_path, $path_export) || do {
            my $err = $!;
            stage_clean();
            die "Could not rename '$stage_path' to '$path_export': $err";
        };
        unstage_tmp();
        dir_ro($path_export);
    }
    my $escaped = escape(cwd_path($path_export));
    $client->output(CODE_EXPORTED, "$revision $escaped");
}

sub on_line {
    my ($client, $line) = @_;

    my @args = split " ", $line or return;
    $_ = unescape($_) for @args;
    my $command = uc shift @args;
    my $id    = $client->id;

    if ($command eq "EXPORT") {
        if (@args < 1) {
            $client->output(CODE_WRONG_ARGUMENTS, "Missing argument(s)");
            return;
        }
        my $repo   = shift @args;
        my $commit = shift @args // "HEAD";
        if (@args) {
            $client->output(CODE_WRONG_ARGUMENTS, "Spurious argument(s)");
            return;
        }
        export($client, $repo, $commit);
        return;
    } elsif ($command eq "HELP") {
        $client->output(CODE_HELP, <<"EOT")
Commands supported:
EXPORT <repo> [<commit>]
QUIT
SHUTDOWN
HELP
EOT
            ;
    } elsif ($command eq "QUIT") {
        $client->finish(CODE_QUIT, "Manual quit", "Goodbye");
    } elsif ($command eq "SHUTDOWN") {
        Git::ExportDaemon->shutdown("Manual shutdown by client '$id'");
        # Cleanup before shutdown
        state_read();
    } else {
        $client->output(CODE_UNKNOWN_COMMAND, "Unknown command '$command'");
    }
}

sub on_accept {
    my ($client) = @_;

    my $pid   = $client->pid;
    my $user  = $client->user;
    my $group = $client->group;
    my $id    = $client->id;
    report("info", "Client '$id' connected: pid $pid, user $user, group $group");
}

my $lock;
eval {
    umask($umask);

    report_start();
    report("info", "Running as pid $$");

    trust_check(PATH_BASE);
    dir_rw(PATH_BASE);
    $lock = lock_file(cwd_path(LOCK_PATH));

    my $fh = is_systemd();
    if ($fh) {
        stat($fh) or die "Could not stat passed filehandle: $!";
        -S $fh || die "Passed filehandle is not a socket\n";
    } else {
        my $fd = fileno(STDIN);
        if (defined $fd) {
            stat(STDIN) or die "Could not stat STDIN: $!";
            $fh = \*STDIN if -S _;
        }
        if (!$fh) {
            if (-e PATH_SOCKET) {
                -S _ || die "Path '", PATH_SOCKET, "' exists but is not a socket\n";
                die "Something is still listening on '", PATH_SOCKET, "'\n" if
                    IO::Socket::UNIX->new(Peer => PATH_SOCKET);
            } else {
                # Check for dangling symlink
                -l PATH_SOCKET;
            }
            !-e _ || unlink(PATH_SOCKET) || $! == ENOENT || $! == ESTALE ||
                    die "Could not unlink '", PATH_SOCKET, "': $!";
            $fh = IO::Socket::UNIX->new(
                Local => PATH_SOCKET,
                Listen => undef) ||
                    die "Could not open UNIX socket ", PATH_SOCKET, "($!)";
            $private_socket = PATH_SOCKET;
            report("info",
                   "Created listening socket '%s'", cwd_path($private_socket));
            -S $fh || die "Assertion: Just created IO::Socket::UNIX filehandle is not a socket";
        }
    }

    rmtree(PATH_STAGE, silent => 1);
    mkdir(PATH_STAGE, 0700) || die "Could not mkdir(", PATH_STAGE, "): $!";
    state_read();

    Git::ExportDaemon->init();
    Git::ExportDaemon->listener(
        $fh,
        on_quit   => \&on_quit,
        on_line   => \&on_line,
        on_accept => \&on_accept,
    );
    Git::ExportDaemon->loop();
    report("info", "Exit");
};
my $err = $@;
unlink($private_socket) if defined $private_socket;
if ($err) {
    report("err", $err);
    report("info", "Exit");
    die $err;
}
